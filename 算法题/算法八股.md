# 算法八股

### 目录
[TOC]

### 1 优先级队列
```python
import heapq


class Student:
    def __init__(self, name, grade):
        self.name = name
        self.grade = grade

    def __lt__(self, other):
        return self.grade > other.grade if self.grade != other.grade else self.name < other.name

    def __str__(self):
        return f"name is {self.name}, grade is {self.grade}"


if __name__ == '__main__':
    q = []
    heapq.heappush(q, Student('tony', 89))
    heapq.heappush(q, Student('tom', 89))
    heapq.heappush(q, Student('rainbow', 99))
    heapq.heappush(q, Student('terry', 65))
    heapq.heappush(q, Student('Newton', 100))
    heapq.heappush(q, Student('trump', 69))

    for i in range(1, len(q) + 1):
        student = heapq.heappop(q)
        print(f"rank: {i},", student)


```
### 2 BFS
求解从（0，0）到（tr，tc）的最短距离
```python
from typing import List

DIRECTIONS = [[1, 0], [0, 1], [-1, 0], [0, -1]]


def min_path_length(grids: List[List[int]], tr: int, tc: int):
    """求解从（0，0）到（tr，tc）的最短距离"""
    m, n = len(grids), len(grids[0])

    q = [[0, 0]]
    path_length = 0
    while q:
        path_length += 1
        for _ in range(len(q)):
            i, j = q.pop()
            for d1, d2 in DIRECTIONS:
                ni, nj = i + d1, j + d2
                if ni < 0 or ni >= m or nj < 0 or nj >= n or grids[ni][nj] == 0:
                    continue

                grids[ni][nj] = 0
                if ni == tr and nj == tc:
                    return path_length

                q.append([ni, nj])
    return -1

```